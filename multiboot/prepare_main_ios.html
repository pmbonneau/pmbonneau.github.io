<!DOCTYPE html>
<html lang="en-US">
<head>

<link rel="icon" href="../apple-touch-icon.png">
<link rel="stylesheet" type="text/css" href="../common/general.css">

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1">

<title>iOS Multiboot - Prepare main iOS</title>

</head>

<body>

<div class="main">

<h1>Prepare main iOS</h1>

<p align="justify">
Jailbreak the main iOS install using your favorite way.
<img class="align" src="resources/preparing_main_ios-jailbreak_pangu_menu.png">
<img class="align" src="resources/preparing_main_ios-jailbreak_pangu_injecting.png">
<img class="align" src="resources/preparing_main_ios-jailbreak_pangu_processing.png">

The most important thing is that code signing enforcement with AMFI (Apple Mobile File Integrity) are disabled to allow launching kloader executable and <span class="cli">task_for_pid0</span> is enabled to allow kloader to do its magic.
Once you have Cydia installed on your device, add http://pmbonneau.com/cydia repository.
<br></br>
Search for, then install the following packages:
<ul>
<li><span class="cli">openssh</span> (Saurik's repo) - SSH protocol must be enabled in order to send commands and transfert files to the device.</li>
<li><span class="cli">hfs_resize</span> (pmbonneau's repo) - This tool allows resizing a mounted HFS+ volume.</li>
<li><span class="cli">gptfdisk</span> (pmbonneau's repo) - A partition manager</li>
<li><span class="cli">mksysbag</span> - Calls <span class="cli">MobileKeyBag.framework</span> to regenerate a system keybag.</li>
<li><span class="cli">kloader6</span> - (pmbonneau's repo) - Jump back to low-level code from userland.</li>
</ul>
Before go further in the main iOS userland preparation, let's test our multiboot low-level setup. This will cost less time to start over if something isn't properly flashed or working as expected.
<br></br>
Setup LLB images for kloader
From a SSH connection, create a directory named "bootloaders" at root of your main iOS system partition.
</p>
<p class="cli">mkdir /bootloaders</p>

Using SCP, transfert the patched LLB images to /bootloaders on the device. Be sure that the LLB images are a RAW ARM binary image, not packed into a .img3 container because kloader will try to run the img3 header as code. This might cause unexpected behaviour.
<p class="cli">pmbonneau-mac#scp -P 2022 LLBB.n90ap.bin root@localhost:/bootloaders</p>
<p class="cli">pmbonneau-mac#scp -P 2022 LLBC.n90ap.bin root@localhost:/bootloaders</p>
<img class="align" src="resources/preparing_main_ios-jailbreak_ssh_transfert_llbb.png">

Launch kloader with the patched LLB image.
<p class="cli">iphone-n90ap#kloader6 /bootloaders/LLBB.n90ap.bin</p>
<img class="align" src="resources/preparing_main_ios-kloader_llbb.png">
To do the following checks, I strongly recommand using a serial cable.
<br></br>
Press home or power button to boot the patched LLB image. It should jump to the patched iBoot (screen light-up), display iOS 6.1.3 bootlogo, then iOS 6.1.3 recovery logo.
<br></br>
Using irecovery, connect to the recovery mode device.
<p class="cli">pmbonneau-mac#irecovery -s</p>
You should see <span class="cli">Kernelcache image not valid</span> before the irecovery command line prompt.
<br></br>
If you have a serial cable, plug your device with it before running kloader. Once the patched bootchain is starting, you should see iBoot live logging.
Verify that all additional images you flashed are found by the bootloader.
<img class="align" src="resources/preparing_main_ios-serial_image_list.png">
You should see all type tags you set to additional images. While I was taking screenshots for this writeup, I noticed that <span class="cli">logc</span> and <span class="cli">recc</span> are missing. This is probably because the two additional iBoot I flashed are taking most of the nand_firmware free space.
<img class="align" src="resources/preparing_main_ios-serial_iboot_log_1.png">
<img class="align" src="resources/preparing_main_ios-serial_iboot_log_2.png">
<p align="justify">
You should see <span class="cli">Kernelcache image not valid</span> like on the screenshot above. This error is currently a normal behaviour, because the kernelcache for our secondary operating systems is not installed yet.
Seeing <span class="cli">Kernelcache image not valid</span> means that iBoot is ready to find and load the kernelcache image. At this point, the devicetree image should be properly loaded.
</p>
<p align="justify">
Resize main data partition
An iOS default install comes with two visible partitions, system and data.
The system partition stores the iOS system files and the data partition stores user data.
Each additional iOS systems will require two partitions, just like the main one.
An iOS multiboot partition layout should looks like this.
<ul>
<li>System (Main OS system partition)</li>
<li>Data (Main OS data partition)</li>
<li>SystemB (Secondary OS system partition)</li>
<li>DataB (Secondary OS data partition)</li>
<li>SystemC (Third OS system partition)</li>
<li>DataC (Third OS data partition)</li>
<li>SystemD (Fourth OS system partition)</li>
<li>DataD (Fourth OS data partition)</li>
</ul>
 
Brief history of how disk partition scheme was used along iOS versions.
<ul>
<li>From iOS 1.x to 3.x : MBR</li>
<li>From late 3.x to 4.3.5 : Regular GPT</li>
<li>From 5.x to 13.x : LwVM + GPT</li>
</ul>

LwVM was introduced with iOS 5. It has some similarities with LVM on Unix systems, such as dynamic partition resizing. This feature was indeed useful when iOS OTA updates were introduced.
When doing an OTA update, iOS resizes the current Data partition then creates a tiny third partition called <span class="cli">Upgrade</span> to hold bootloader images and update ramdisk.
 
In order to add new partitions, the last partition of the main OS must be shrunk to free up some space (main OS data partition takes all the remaining space by default).
There's a tool created by @Danzatt called <span class="cli">hfs_resize</span>, which can be used to resize a mounted HFS+ volume. It is based on the userland iOS OTA upgrade routines.
A basic iOS install is usually splitted somewhat like that for a 32 GB device. Around 2.5 GB allocated for the system partition and around 28.3 GB for user data partition.
<br></br>
For an iOS 7.1.2 with iOS 6.1.3 and 5.1.1 triple-boot on a 32 GB iPhone 4, we could plan a disk setup like this.
<ul>
<li>System (iOS 7.1.2 system partition) -- 2.5 GB</li>
<li>Data (iOS 7.1.2 data partition) ------ 8 GB</li>
<li>SystemB (iOS 6.1.3 system partition) - 2.4 GB</li>
<li>DataB (iOS 6.1.3 data partition) ----- 8 GB</li>
<li>SystemC (iOS 5.1.1 system partition) - 2.4 GB</li>
<li>DataC (iOS 5.1.1 data partition) ----- 8 GB</li>
</ul>
</p>
We must reduce our iOS 7.1.2 data partition to 8 GB using <span class="cli">hfs_resize</span>.
<p class="cli">iphone-root#hfs_resize [mount point] [capacity in bytes]</p>
The mount point is the folder where your disk device is mounted. For iOS, the data partition is always mounted in <span class="cli">/private/var</span> of the root filesystem.
For the resized data partition size, you have to manually calculate it. For example, you want 8 GB as primary OS data partition.
<br></br>
1 GB = 1024 * 1024 * 1024 = 1073741824 bytes
<br></br>
8 GB = 8 * 1073741824 = 8589934592
<br></br>
Our command to reduce the iOS 7.1.2 data partition to 8 GB would be like this.
<p class="cli">iphone-root#hfs_resize /private/var/ 8589934592</p>
<img class="align" src="resources/preparing_main_ios-hfsresize_main_data.png">
If we check in device settings, we should see that our main iOS install now have a total of 8 GB capacity.
</p>
<center><a href="partition_lwvm_table.html" class="menu"><b>> Part 10:</b> Partition LwVM table</a></center><br>
</div>

<footer>
	Copyright © 2019 — Pierre-Marc Bonneau<br>
	<a href="https://twitter.com/shadowlee19"><img src="../common/twitter.png" height=44 width=44></a>
	<a href="https://github.com/pmbonneau"><img src="../common/github.png" height=44 width=44></a>
	<a href="mailto:pmbonneau@pmbonneau.com"><img src="../common/mail.png" height=45 width=45></a>
</footer>

</body>
</html>